<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> <html> <head> <title>StdUtils plug-in</title> <meta http-equiv="content-type" content="text/html; charset=UTF-8"> <meta http-equiv="expires" content="0"> <meta http-equiv="cache-control" content="no-cache"> <meta http-equiv="pragma" content="no-cache"> <style type="text/css"><!-- p{text-align:justify}pre{background-color:#ececec}tt{background-color:#f0f0f0}--></style> </head> <body> <table width="100%"> <tr> <td align="left"><a href="http://muldersoft.com/">http://muldersoft.com/</a> | <a href="http://sourceforge.net/projects/muldersoft/">http://sourceforge.net/projects/muldersoft/</a> | <a href="http://nsis.sourceforge.net/Category:Plugins">http://nsis.sourceforge.net/Category:Plugins</a></td> <td align="right"><a href="https://www.youtube.com/v/uKUYSl8c-90?autoplay=1">Earth Heals Herself</a></td> </tr> </table> <hr> <br> <h1><u>StdUtils - Swiss Army Knife for NSIS</u></h1> <p>This plug-in provides access to a number of "standard" functions from the <a href="http://en.wikipedia.org/wiki/C_standard_library">C Standard Library</a>, which programmers are used to from C/C++ and other "high level" languages, but which are <i>not</i> normally available in NSIS. In order to keep the plug-in size as small as possible and for maximum compatibility, the Visual C++ Runtime v6.0 "MSVCRT.DLL" is used, which is an integral part of all versions of Windows (since Windows 2000). This means that the C++ Runtime neither needs to be shipped as a separate DLL nor does it need to be linked <i>statically</i> into the plug-in. <p>Many additional functions, <i>not</i> directly related to the C Standard Library, have been added over the years: For example, this plug-in provides a number convenience functions to deal with <i>strings</i>, such as trimming whitespace or validating a given file name. There also are some functions to conveniently access the <i>command-line parameters</i> that have been passed to the installer. Furthermore, there is a wrapper for the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb762164%28v=vs.85%29.aspx">SHFileOperation</a> function, which can be used to <i>copy or move files</i> using the Windows Shell, as well as a function to efficiently <i>append</i> the contents of one file to another file. Moreover, the plug-in provides a method for launching programs in a <i>non-elevated</i> way (aka "user mode") from an installer that is running in <i>elevated</i> context (aka "admin mode"). In addition to that, there is a set of functions that can be used to detect the <i>real</i> Windows version that the installer is running on, which still work correctly/reliably on Windows 8.1 (and later) where Microsoft has <i style="color:darkred">broken</i> the GetVersionEx() system function. And, as if this wasn't enough, the plug-in can compute the <i>cryptographic hash</i> of a given file or text message, using various state-of-the-art hash functions, including SHA-{1,2,3}. Last but not least, the plug-in provides a variant of <tt>ExecShell</tt> with "wait for process termination" feature, based on <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb762154%28v=vs.85%29.aspx">ShellExecuteEx</a>, as well as a function for invoking "shell verbs" &ndash; useful for programmatically <i>pinning shortcuts to the Taskbar</i>.</p> <p>Overall I use this plug-in as my "Swiss Army Knife" for all the small things I needed in my NSIS-based installers but that NSIS didn't provide out-of-the-box. <b>ANSI</b> <i>and</i> <b>Unicode</b> builds are provided. Supports all Windows versions, starting with <b>Windows XP</b>.</p> <br> <b>Table of Contents:</b> <ul> <li><a href="#53826d99">Available Functions</a> <li><a href="#e5717960">Installation</a> <li><a href="#72a4075a">General Usage</a> <li><a href="#17095e85">Function Reference</a> <ul> <li><a href="#66dd4753">Time Functions: <tt>Time</tt> / <tt>GetMinutes</tt> / <tt>GetHours</tt> / <tt>GetDays</tt></a> <li><a href="#dc3f60d9">Pseudorandom Number Generator: <tt>Rand</tt> / <tt>RandMax</tt> / <tt>RandMinMax</tt> / <tt>RandList</tt> / <tt>RandBytes</tt></a> <li><a href="#23711935">String Functions: <tt>FormatStr</tt> / <tt>ScanStr</tt> / <tt>TrimStr</tt> / <tt>RevStr</tt> / <tt>Valid{FileName,PathSpec,DomainName}</tt> / <tt>Str{To,From}Utf8</tt></a> <li><a href="#df333b53">Shell File Operation: <tt>SHFileCopy</tt> / <tt>SHFileMove</tt></a> <li><a href="#18e9c5cb">File manipulation: <tt>AppendToFile</tt></a> <li><a href="#a3d3af46">Create Process Functions: <tt>ExecShellAsUser</tt> / <tt>ExecShellWait</tt> / <tt>WaitForProcEx</tt></a> <li><a href="#f24cc3f9">Command-line Functions: <tt>{Test,Get}Parameter</tt> / <tt>Parameter{Cnt,Str}</tt> / <tt>GetAllParameters</tt></a> <li><a href="#d452a779">Windows Shell: <tt>InvokeShellVerb</tt></a> <li><a href="#f57ec206">OS Version Functions: <tt>GetRealOSVersion</tt> / <tt>GetRealOSName</tt> / <tt>VerifyOSVersion</tt> / <tt>GetOSEdition</tt></a> <li><a href="#e1f7e07b">Cryptographic Hash Functions: <tt>HashText</tt> / <tt>HashFile</tt></a> <li><a href="#fe8b67bc">Path Utility Functions: <tt>NormalizePath</tt> / <tt>GetParentPath</tt> / <tt>SplitPath</tt></a> <li><a href="#fe7af29a">Cryptographic Functions: <tt>ProtectStr</tt> / <tt>UnprotectStr</tt></a> <li><a href="#5247e2cd">Window Timer Functions: <tt>TimerCreate</tt> / <tt>TimerDestroy</tt></a> <li><a href="#14863bf9">Debugging Functions</a> </ul> <li><a href="#db579654">License</a> <li><a href="#b92197af">Acknowledgment</a> <li><a href="#01efe0f2">Download and Sources</a> <li><a href="#8d7f91f6">Help & Support</a> <li><a href="#53c38996">Version History</a> </ul> <br> <a name="53826d99"></a><h1>Available Functions</h1> <p>The following functions are provided by the StdUtils plug-in: <pre>!define StdUtils.Time             #time(), as in C standard library
!define StdUtils.GetMinutes       #GetSystemTimeAsFileTime(), returns the number of minutes
!define StdUtils.GetHours         #GetSystemTimeAsFileTime(), returns the number of hours
!define StdUtils.GetDays          #GetSystemTimeAsFileTime(), returns the number of days
!define StdUtils.Rand             #rand(), as in C standard library
!define StdUtils.RandMax          #rand(), as in C standard library, with maximum value
!define StdUtils.RandMinMax       #rand(), as in C standard library, with minimum/maximum value
!define StdUtils.RandList         #rand(), as in C standard library, with list support
!define StdUtils.RandBytes        #Generates random bytes, returned as Base64-encoded string
!define StdUtils.FormatStr        #sprintf(), as in C standard library, one '%d' placeholder
!define StdUtils.FormatStr2       #sprintf(), as in C standard library, two '%d' placeholders
!define StdUtils.FormatStr3       #sprintf(), as in C standard library, three '%d' placeholders
!define StdUtils.ScanStr          #sscanf(), as in C standard library, one '%d' placeholder
!define StdUtils.ScanStr2         #sscanf(), as in C standard library, two '%d' placeholders
!define StdUtils.ScanStr3         #sscanf(), as in C standard library, three '%d' placeholders
!define StdUtils.TrimStr          #Remove whitspaces from string, left and right
!define StdUtils.TrimStrLeft      #Remove whitspaces from string, left side only
!define StdUtils.TrimStrRight     #Remove whitspaces from string, right side only
!define StdUtils.RevStr           #Reverse a string, e.g. "reverse me" <-> "em esrever"
!define StdUtils.ValidFileName    #Test whether string is a valid file name - no paths allowed
!define StdUtils.ValidPathSpec    #Test whether string is a valid full(!) path specification
!define StdUtils.ValidDomainName  #Test whether string is a valid host name or domain name
!define StdUtils.StrToUtf8        #Convert string from Unicode (UTF-16) or ANSI to UTF-8 bytes
!define StdUtils.StrFromUtf8      #Convert string from UTF-8 bytes to Unicode (UTF-16) or ANSI
!define StdUtils.SHFileMove       #SHFileOperation(), using the FO_MOVE operation
!define StdUtils.SHFileCopy       #SHFileOperation(), using the FO_COPY operation
!define StdUtils.AppendToFile     #Append contents of an existing file to another file
!define StdUtils.ExecShellAsUser  #ShellExecute() as NON-elevated user from elevated installer
!define StdUtils.InvokeShellVerb  #Invokes a "shell verb", e.g. for pinning items to the taskbar
!define StdUtils.ExecShellWaitEx  #ShellExecuteEx(), returns the handle of the new process
!define StdUtils.WaitForProcEx    #WaitForSingleObject(), e.g. to wait for a running process
!define StdUtils.GetParameter     #Get the value of a specific command-line option
!define StdUtils.TestParameter    #Test whether a specific command-line option has been set
!define StdUtils.ParameterCnt     #Get number of command-line tokens, similar to argc in main()
!define StdUtils.ParameterStr     #Get the n-th command-line token, similar to argv[i] in main()
!define StdUtils.GetAllParameters #Get complete command-line, but without executable name
!define StdUtils.GetRealOSVersion #Get the *real* Windows version number, even on Windows 8.1+
!define StdUtils.GetRealOSBuildNo #Get the *real* Windows build number, even on Windows 8.1+
!define StdUtils.GetRealOSName    #Get the *real* Windows version, as a "friendly" name
!define StdUtils.GetOSEdition     #Get the Windows edition, i.e. "workstation" or "server"
!define StdUtils.GetOSReleaseId   #Get the Windows release identifier (on Windows 10)
!define StdUtils.VerifyOSVersion  #Compare *real* operating system to an expected version number
!define StdUtils.VerifyOSBuildNo  #Compare *real* operating system to an expected build number
!define StdUtils.HashText         #Compute hash from text string (CRC32, MD5, SHA1/2/3, BLAKE2)
!define StdUtils.HashFile         #Compute hash from file (CRC32, MD5, SHA1/2/3, BLAKE2)
!define StdUtils.NormalizePath    #Simplifies the path to produce a direct, well-formed path
!define StdUtils.GetParentPath    #Get parent path by removing the last component from the path
!define StdUtils.SplitPath        #Split the components of the given path
!define StdUtils.GetDrivePart     #Get drive component of path
!define StdUtils.GetDirectoryPart #Get directory component of path
!define StdUtils.GetFileNamePart  #Get file name component of path
!define StdUtils.GetExtensionPart #Get file extension component of path
!define StdUtils.TimerCreate      #Create a new event-timer that will be triggered periodically
!define StdUtils.TimerDestroy     #Destroy a running timer created with TimerCreate()
!define StdUtils.ProtectStr       #Protect a given String using Windows' DPAPI
!define StdUtils.UnprotectStr     #Unprotect a string that was protected via ProtectStr()
!define StdUtils.GetLibVersion    #Get the current StdUtils library version (for debugging)
!define StdUtils.SetVerbose       #Enable or disable "verbose" mode (for debugging)</pre> <p><b style="color:darkred">Please see the descriptions below for details on the individual functions!</b></p> <br> <a name="e5717960"></a><h1>Installation</h1> <p>Depending on whether you are using the <b>Unicode</b> or the <b>ANSI</b> (non-Unicode) variant of NSIS, you must copy either <tt>Plugins\Release_<span style="color:darkred">Unicode</span>\StdUtils.dll</tt> or <tt>Plugins\Release_<span style="color:darkred">ANSI</span>\StdUtils.dll</tt> into the <tt>Plugins</tt> sub-directory inside your NSIS installation. Using the <b>Unicode</b> version is <i>highly recommended</i> these days! Also, <i>in both cases</i>, you must copy <tt>Include\StdUtils.nsh</tt> into the <tt>Include</tt> sub-directory inside your NSIS installation. Please note that NSIS v2.x does <u>not</u> officially support Unicode, but you can (and should!) use <a href="http://www.scratchpaper.com/"><b>Unicode NSIS</b></a>. Unicode support will officially be added to NSIS v3.x, which currently is still in development stage. Therefore, the <b>Unicode</b> version of this plug-in has been developed and tested with <i>Unicode NSIS</i> v2.x, <b>not</b> with NSIS v3.x. Support for NSIS v3.x is going to be added as soon as it will be released.</p> <p>Hint: The release package now also contains a "tiny" version of this plug-in. That version has about 1/3 the size of the "normal" (full) version, but lacks support for hash computation. The "tiny" version is provided as <i>Unicode</i> build only!</p> <br> <a name="72a4075a"></a><h1>General Usage</h1> <p>In order to use the StdUtils plug-in in your script, simply include <tt>StdUtils.nsh</tt> and then use the pre-defined <tt>${StdUtils.<i>FunctionName</i>}</tt> macros like this:</p> <pre>!include '<span style="color:darkred;font-weight:bold;">StdUtils.nsh</span>'

Section
	<span style="color:darkred;font-weight:bold;">${StdUtils.Rand}</span> $1
	DetailPrint "Random number obtained via StdUtils::Rand is: $1"
SectionEnd</pre> <p>Note: We highly recommend to <u>not</u> call the plug-in functions directly. Instead, use the pre-defined macros, which ensures that the plug-in functions are used in the "proper" way.</p> <p>For more details, please have a look at the example scripts located in the <tt>StdUtils\Examples\StdUtils</tt> directory!</p> <br> <a name="17095e85"></a><h1>Function Reference</h1> <p>In this chapter the individual functions provided by the <i>StdUtils</i> plug-in are described in detail.</p> <br> <a name="66dd4753"></a><h2>Time Functions</h2> <p><b><tt>${StdUtils.Time} <i>user_var(output)</i></tt></b></p> <p>Returns the number of seconds that have elapsed since 00:00, Jan 1, 1970 (UTC), also known as "Unix time", just like the <a href="http://www.cplusplus.com/reference/clibrary/ctime/time/">time()</a> function: <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.Time} $1
	DetailPrint "Time: $1"
	Sleep 500
	${StdUtils.Time} $1
	DetailPrint "Time: $1"
	Sleep 500
	${StdUtils.Time} $1
	DetailPrint "Time: $1"
SectionEnd</pre> <p><br><b><tt>${StdUtils.GetMinutes} <i>user_var(output)</i><br>${StdUtils.GetHours} <i>user_var(output)</i><br>${StdUtils.GetDays} <i>user_var(output)</i></tt></b></p> <p>Retrieves the current system date and time, using the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724397%28v=vs.85%29.aspx">GetSystemTimeAsFileTime()</a> function. Returns the number of <i>minutes</i>, <i>hours</i> or <i>days</i> since 00:00, January 1, 1601 (UTC). <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.GetMinutes} $1
	DetailPrint "UTC time in minutes: $1"
	${StdUtils.GetHours} $1
	DetailPrint "UTC time in hours: $1"
	${StdUtils.GetDays} $1
	DetailPrint "UTC time in days: $1"
SectionEnd</pre> <br> <a name="dc3f60d9"></a><h2>Pseudorandom Number Generator (PRNG)</h2> <p><b><tt>${StdUtils.Rand} <i>user_var(output)</i><br>${StdUtils.RandMax} <i>user_var(output)</i> <i>max</i><br>${StdUtils.RandMinMax} <i>user_var(output)</i> <i>min</i> <i>max</i></tt></b></p> <p>Returns a pseudo-random integral number, similar to the <a href="http://www.cplusplus.com/reference/clibrary/cstdlib/rand/">rand()</a> function. Optionally, the <i>minimum</i> and <i>maximum</i> value can be specified via the <tt>min</tt> and <tt>max</tt> parameters; the <tt>max</tt> parameter <i>must not</i> exceed <a href="https://msdn.microsoft.com/en-us/library/s3f49ktz.aspx"><tt>INT_MAX</tt></a>; the <tt>min</tt> parameter <i>must not</i> deceed <a href="https://msdn.microsoft.com/en-us/library/s3f49ktz.aspx"><tt>INT_MIN</tt></a>; and <tt>max</tt> must be greater than or equal to <tt>min</tt>. The random numbers returned are guaranteed to be in the range from <tt>min</tt> to <tt>max</tt>, with both endpoints of the interval <i>included</i>. If the minimum is <i>not</i> specified, it defaults to <tt>0</tt>; and if the maximum is <i>not</i> specified, it defaults to <tt>INT_MAX</tt>. Note that this function will use the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694%28v=vs.85%29.aspx">RtlGenRandom()</a> API, whenever possible; otherwise it falls back to a method based on <tt>rand()</tt>. In the latter case, <tt>srand()</tt> will be initialized with a suitable seed <i>automatically</i>. If the function was called with invalid parameter, it returns "einval" and sets the error flag.</p> <pre>Section
	${StdUtils.Rand} $1
	DetailPrint "Random: $1"
	${StdUtils.Rand} $1
	DetailPrint "Random: $1"
	${StdUtils.Rand} $1
	DetailPrint "Random: $1"
	${StdUtils.Rand} $1
	DetailPrint "Random: $1"
	${StdUtils.Rand} $1
	DetailPrint "Random: $1"
	${StdUtils.Rand} $1
	DetailPrint "Random: $1"
SectionEnd

Section
	${StdUtils.RandMax} $1 42
	DetailPrint "Random Max: $1"
	${StdUtils.RandMax} $1 42
	DetailPrint "Random Max: $1"
	${StdUtils.RandMax} $1 42
	DetailPrint "Random Max: $1"
	${StdUtils.RandMax} $1 42
	DetailPrint "Random Max: $1"
	${StdUtils.RandMax} $1 42
	DetailPrint "Random Max: $1"
	${StdUtils.RandMax} $1 42
	DetailPrint "Random Max: $1"
SectionEnd

Section
	${StdUtils.RandMinMax} $1 -4 -2
	DetailPrint "Random Min/Max: $1"
	${StdUtils.RandMinMax} $1 -4 -2
	DetailPrint "Random Min/Max: $1"
	${StdUtils.RandMinMax} $1 -4 -2
	DetailPrint "Random Min/Max: $1"
	${StdUtils.RandMinMax} $1 -4 -2
	DetailPrint "Random Min/Max: $1"
	${StdUtils.RandMinMax} $1 -4 -2
	DetailPrint "Random Min/Max: $1"
	${StdUtils.RandMinMax} $1 20 21
	DetailPrint "Random Min/Max: $1"
SectionEnd</pre> <p><br><b><tt>${StdUtils.RandList} <i>count</i> <i>max</i></tt></b></p> <p>Pushes a list of pseudo-random numbers onto the stack. The string "EOL" is pushed beforehand and thus will indicate the end of the list when popping the numbers off the stack. The quantity of the random numbers in the list can be controlled via the <tt>count</tt> parameter. Each number is guaranteed to be in the range from <tt>0</tt> to <tt>max</tt>, with both endpoints of the interval <i>included</i>. Also, each number appears <i>at most</i> once in the list. If the function was called with invalid parameters, it returns "einval" and sets the error flag.</p> <pre>Section
	${StdUtils.RandList} 50 100
	Pop $1
	StrCmp $1 EOL +3
	DetailPrint "RandList: $1"
	Goto -3
SectionEnd</pre> <p><br><b><tt>${StdUtils.RandBytes} <i>user_var(output)</i> <i>count</i></tt></b></p> <p>Generates a sequence of pseudo-random bytes. The length of the sequence, in bytes, can be controlled by the <tt>count</tt> parameter. The generated bytes are encoded and returned as a <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> string &ndash; the length of the returned string is about <tt>(count/3)&times;4</tt> characters. If the specified count is invalid, then "einval" is returned; if the length of the Base64-encoded string would exceed to maximum string length supported by NSIS, then "too_long" is returned; and if other errors occur, then "error" is returned. Also, if anything goes wrong, the error flag is set.</p> <pre>Section
	${StdUtils.RandBytes} $1 100
	DetailPrint "100 random bytes: $1"
	${StdUtils.RandBytes} $1 100
	DetailPrint "100 random bytes: $1"
	${StdUtils.RandBytes} $1 100
	DetailPrint "100 random bytes: $1"
SectionEnd</pre> <br> <a name="23711935"></a><h2>String Functions</h2> <p><b><tt>${StdUtils.FormatStr} <i>user_var(output)</i> <i>format_str</i> <i>val1</i><br>${StdUtils.FormatStr2} <i>user_var(output)</i> <i>format_str</i> <i>val1</i> <i>val2</i><br>${StdUtils.FormatStr3} <i>user_var(output)</i> <i>format_str</i> <i>val1</i> <i>val2</i> <i>val3</i></tt></b></p> <p>Returns a formatted string, similar to the <a href="http://www.cplusplus.com/reference/clibrary/cstdio/sprintf/">sprintf()</a> function. Only the <tt>%d</tt> placeholder is currently supported. There are versions for one, two and three placeholders:</p> <pre>Section
	${StdUtils.FormatStr} $1 "Hello World is %05d woha!" 89
	DetailPrint "FormatStr: $1"
	${StdUtils.FormatStr2} $1 "Hello World is %05d and %05d woha!" 89 384
	DetailPrint "FormatStr: $1"
	${StdUtils.FormatStr3} $1 "Hello World is %05d and %05d or even %05d woha!" 89 384 2384
	DetailPrint "FormatStr: $1"
	${StdUtils.FormatStr} $1 "Hello World is %09000d." 89
	DetailPrint "FormatStr: $1"
SectionEnd</pre> <p><br><b><tt>${StdUtils.ScanStr} <i>user_var(output)</i> <i>format_str</i> <i>input</i> <i>default</i><br>${StdUtils.ScanStr2} <i>user_var(output1)</i> <i>user_var(output2)</i> <i>format_str</i> <i>input</i> <i>default1</i> <i>default2</i><br>${StdUtils.ScanStr3} <i>user_var(output1)</i> <i>user_var(output2)</i> <i>user_var(output3)</i> <i>format_str</i> <i>input</i> <i>default1</i> <i>default2</i> <i>default3</i></tt></b></p> <p>Parses input from a string according to a format specification similar to the <a href="http://www.cplusplus.com/reference/clibrary/cstdio/sscanf/">sscanf()</a> function. Only the <tt>%d</tt> placeholder is currently supported. There are versions for one, two and three placeholders:</p> <pre>Section
	${StdUtils.ScanStr} $0 "Der Test sagt %d ist toll!" "Der Test sagt 571 ist toll!" 42
	DetailPrint "ScanStr: $0"
	${StdUtils.ScanStr} $0 "Der Hund sagt %d ist toll!" "Der Test sagt 571 ist toll!" 42
	DetailPrint "ScanStr: $0"
SectionEnd

Section
	${StdUtils.ScanStr2} $0 $1 "Der Test sagt %d sowie %d ist toll!" "Der Test sagt 571 sowie 831 ist toll!" 42 43
	DetailPrint "ScanStr2: $0, $1"
	${StdUtils.ScanStr2} $0 $1 "Der Test sagt %d sowie %d ist toll!" "Der Test sagt 571 horch 831 ist toll!" 42 43
	DetailPrint "ScanStr2: $0, $1"
	${StdUtils.ScanStr2} $0 $1 "Der Test sagt %d sowie %d ist toll!" "Der Hund sagt 571 horch 831 ist toll!" 42 43
	DetailPrint "ScanStr2: $0, $1"
SectionEnd

Section
	${StdUtils.ScanStr3} $0 $1 $2 "Der Test sagt %d sowie %d ist toll! Und %d." "Der Test sagt 571 sowie 831 ist toll! Und 325" 42 43 44
	DetailPrint "ScanStr3: $0, $1, $2"
	${StdUtils.ScanStr3} $0 $1 $2 "Der Test sagt %d sowie %d ist toll! Und %d." "Der Test sagt 571 sowie 831 ist toll! OMG 325" 42 43 44
	DetailPrint "ScanStr3: $0, $1, $2"
	${StdUtils.ScanStr3} $0 $1 $2 "Der Test sagt %d sowie %d ist toll! Und %d." "Der Test sagt 571 horch 831 ist toll! OMG 325" 42 43 44
	DetailPrint "ScanStr3: $0, $1, $2"
	${StdUtils.ScanStr3} $0 $1 $2 "Der Test sagt %d sowie %d ist toll! Und %d." "Der Hund sagt 571 horch 831 ist toll! OMG 325" 42 43 44
	DetailPrint "ScanStr3: $0, $1, $2"
SectionEnd</pre> <p><br><b><tt>${StdUtils.TrimStr} <i>user_var(input/output)</i><br>${StdUtils.TrimStrLeft} <i>user_var(input/output)</i><br>${StdUtils.TrimStrRight} <i>user_var(input/output)</i></tt></b></p> <p>Trims a string by removing all leading and/or trailing whitespace characters. A characters is considered to be a "whitespace" character by this function, if (and only if) it is accepted by either <a href="http://www.cplusplus.com/reference/cctype/iscntrl/">iscntrl()</a> or <a href="http://www.cplusplus.com/reference/cctype/isspace/">isspace()</a>. The function operates <i>in-place</i>.</p> <pre>Section
	StrCpy $1 "        Some Text        "
	DetailPrint "String: '$1'"
	StrCpy $0 $1
	${StdUtils.TrimStr} $0
	DetailPrint "TrimStr: '$0'"
	StrCpy $0 $1
	${StdUtils.TrimStrLeft} $0
	DetailPrint "TrimStrLeft: '$0'"
	StrCpy $0 $1
	${StdUtils.TrimStrRight} $0
	DetailPrint "TrimStrRight: '$0'"

	StrCpy $1 "Some Text"
	DetailPrint "String: '$1'"
	StrCpy $0 $1
	${StdUtils.TrimStr} $0
	DetailPrint "TrimStr: '$0'"
	StrCpy $0 $1
	${StdUtils.TrimStrLeft} $0
	DetailPrint "TrimStrLeft: '$0'"
	StrCpy $0 $1
	${StdUtils.TrimStrRight} $0
	DetailPrint "TrimStrRight: '$0'"

	StrCpy $1 ""
	DetailPrint "String: '$1'"
	StrCpy $0 $1
	${StdUtils.TrimStr} $0
	DetailPrint "TrimStr: '$0'"
	StrCpy $0 $1
	${StdUtils.TrimStrLeft} $0
	DetailPrint "TrimStrLeft: '$0'"
	StrCpy $0 $1
	${StdUtils.TrimStrRight} $0
	DetailPrint "TrimStrRight: '$0'"

	StrCpy $1 "   "
	DetailPrint "String: '$1'"
	StrCpy $0 $1
	${StdUtils.TrimStr} $0
	DetailPrint "TrimStr: '$0'"
	StrCpy $0 $1
	${StdUtils.TrimStrLeft} $0
	DetailPrint "TrimStrLeft: '$0'"
	StrCpy $0 $1
	${StdUtils.TrimStrRight} $0
	DetailPrint "TrimStrRight: '$0'"

	StrCpy $1 "$\tFoobar$\r$\n"
	DetailPrint "String: '$1'"
	StrCpy $0 $1
	${StdUtils.TrimStr} $0
	DetailPrint "TrimStr: '$0'"
	StrCpy $0 $1
	${StdUtils.TrimStrLeft} $0
	DetailPrint "TrimStrLeft: '$0'"
	StrCpy $0 $1
	${StdUtils.TrimStrRight} $0
	DetailPrint "TrimStrRight: '$0'"
SectionEnd</pre> <p><br><b><tt>${StdUtils.RevStr} <i>user_var(input/output)</i></tt></b></p> <p>Reverses the character order of a specified string <i>in-place</i>. For example, it converts "reverse me" to "em esrever", or vice versa.</p> <pre>Section
	StrCpy $0 "ABC"
	DetailPrint "String: $0"
	${StdUtils.RevStr} $0
	DetailPrint "RevStr: $0"

	StrCpy $0 "ABCD"
	DetailPrint "String: $0"
	${StdUtils.RevStr} $0
	DetailPrint "RevStr: $0"

	StrCpy $0 "Just a very long text with no specific meaning at all!"
	DetailPrint "String: $0"
	${StdUtils.RevStr} $0
	DetailPrint "RevStr: $0"
SectionEnd</pre> <p><br><b><tt>${StdUtils.ValidFileName} <i>user_var(output)</i> <i>input</i><br>${StdUtils.ValidPathSpec} <i>user_var(output)</i> <i>input</i></tt></b></p> <p>The <tt>${StdUtils.ValidFileName}</tt> function checks whether the given <tt>input</tt> is a valid file name, and the <tt>${StdUtils.ValidPathSpec}</tt> function checks whether the given <tt>input</tt> is a valid fully-qualified path. Both functions return "ok", if the given string is valid, or "invalid" otherwise.</p> <p>Note: File names must <b>not</b> contain any <tt>&lt;&gt;:"/\|?*</tt> characters or any characters accepted by <a href="http://www.cplusplus.com/reference/cctype/iscntrl/">iscntrl()</a>. For paths the same limitations apply, except that a path may contain <tt>/</tt> and <tt>\</tt> characters. Additionally, the <i>first</i> character in a path must be accepted by <a href="http://www.cplusplus.com/reference/cctype/isalpha/">isalpha()</a> and the <i>second</i> character in a path must be a <tt>:</tt> character. However, the <tt>:</tt> character must <b>not</b> appear at any other location in the path. Furthermore, the <i>last</i> character in a file name or path must <b>not</b> be a <tt>.</tt> or whitespace character. Last but not least, an <i>empty</i> string is <b>never</b> accepted as a valid file name or path. <pre>Section
	${StdUtils.ValidFileName} $0 "My Document.txt"
	DetailPrint 'ValidFileName("My Document.txt") = $0'

	${StdUtils.ValidFileName} $0 "Is this a valid name?"
	DetailPrint 'ValidFileName("Is this a valid name?") = $0'

	${StdUtils.ValidPathSpec} $0 "C:\Folder\File.foo"
	DetailPrint 'ValidPathSpec("C:\Folder\File.foo") = $0'
SectionEnd</pre> <p><br><b><tt>${StdUtils.ValidDomainName} <i>user_var(output)</i> <i>input</i></tt></b></p> <p>The <tt>${StdUtils.ValidDomainName}</tt> function checks whether the given <tt>input</tt> is a valid domain name. This can be a fully qualified domain name (FQDN) or just a single hostname. If the given string is a <i>valid</i> domain name, the function returns "ok"; otherwise it returns "invalid".</p> <p>Note: A valid domain name consist of one or more <i>labels</i>. If multiple labels are present, each consecutive pair of labels is separated by a single dot (<tt>.</tt>) character; leading or trailing dots are forbidden. Also, each label consist of one or more characters. The only characters allowed in a label are the upper-case letters <tt>A</tt> to <tt>Z</tt>, the lower-case letters <tt>a</tt> to <tt>z</tt>, the digits <tt>0</tt> to <tt>9</tt> as well as thy hyphen character (<tt>-</tt>). Last but not least, a label <i>must not</i> start or end with a hyphen character. There generally is <i>no</i> distinction between upper-case and lower-case letters.</p> <pre>Section
	${StdUtils.ValidDomainName} $0 "localhost"
	DetailPrint 'ValidDomainName: "localhost" --> $0'

	${StdUtils.ValidDomainName} $0 "de.wikipedia.org"
	DetailPrint 'ValidDomainName: "de.wikipedia.org" --> $0'

	${StdUtils.ValidDomainName} $0 "Ö La Palöma"
	DetailPrint 'ValidDomainName: "Ö La Palöma" --> $0'

	${StdUtils.ValidDomainName} $0 "-foo-"
	DetailPrint 'ValidDomainName: "-foo-" --> $0'

	${StdUtils.ValidDomainName} $0 ".bar."
	DetailPrint 'ValidDomainName: ".bar." --> $0'
SectionEnd</pre> <p><br><b><tt>${StdUtils.StrToUtf8} <i>user_var(output)</i> <i>text</i><br>${StdUtils.StringFromUtf8} <i>user_var(output)</i> <i>trnc</i> <i>data</i></tt></b></p> <p>The <tt>${StdUtils.StrToUtf8}</tt> function converts the given string <tt>text</tt> from either UTF-16 (Unicode version) or the current ANSI codepage (ANSI version) string to the UTF-8 format. The resulting UTF-8 byte sequence, including the terminating NULL character, is returned as a <a href="https://en.wikipedia.org/wiki/Base64">Base64</a>-encoded string. If the length of the encoded data exceeds the maximum NSIS string length, then "too_long" is returned; and if other errors have occurred, then "error" is returned. Furthermore, if anything went wrong, the the error flag is set. <p>The <tt>${StdUtils.StrFromUtf8}</tt> function converts the given UTF-8 byte sequence <tt>data</tt> to a normal string in either UTF-16 format (Unicode version) or the current ANSI codepage (ANSI version). The given input is expected to be valid UTF-8 data, encoded as a Base64 string. Also, the given input sequence is supposed to end with a NULL terminator. The <tt>trnc</tt> parameter controls the behavior of the function, in case that the length of the decoded string exceeds the maximum NSIS string length: If the parameter is set to <tt>1</tt>, then the string is truncated; if the parameter is set to <tt>0</tt>, then the function fails. If the length of the decoded string exceeds the maximum NSIS string length, then "too_long" is returned; and if other errors have occurred, then "error" is returned. Furthermore, if anything went wrong, the the error flag is set. <pre>Section
	ClearErrors

	${StdUtils.StrToUtf8} $1 "The five boxing wizards jump quickly."
	DetailPrint 'UTF-8: "$1"'
	IfErrors 0 +3
	DetailPrint "Whoops, failed unexpectedly!"
	Abort
	
	${StdUtils.StrFromUtf8} $2 0 "$1"
	DetailPrint 'Plain: "$2"'
	IfErrors 0 +3
	DetailPrint "Whoops, failed unexpectedly!"
	Abort
SectionEnd</pre> <br> <a name="df333b53"></a><h2>Shell File Operation</h2> <p><b><tt>${StdUtils.SHFileMove} <i>user_var(output)</i> <i>from</i> <i>to</i> <i>hwnd</i><br>${StdUtils.SHFileCopy} <i>user_var(output)</i> <i>from</i> <i>to</i> <i>hwnd</i></tt></b></p> <p>Copies or moves a file system object (e.g. a <i>file</i> or a complete <i>folder</i>) from path <tt>from</tt> to path <tt>to</tt>, by using the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb762164%28v=vs.85%29.aspx">SHFileOperation()</a> function. The function requires a window handle <tt>hwnd</tt> and usually the NSIS variable <tt>$HWNDPARENT</tt> is used for this purpose.</p> <pre>Section
	InitPluginsDir
	SetOutPath "$PLUGINSDIR\TestDirA"
	File "${NSISDIR}\Contrib\Graphics\Checks\*.*"
	SetOutPath "$PLUGINSDIR\TestDirA\SubDir"
	File "${NSISDIR}\Contrib\Graphics\Header\*.*"
	CreateDirectory "$PLUGINSDIR\SubDirX"
	CreateDirectory "$PLUGINSDIR\SubDirY"

	${StdUtils.SHFileCopy} $0 "$PLUGINSDIR\TestDirA" "$PLUGINSDIR\SubDirX\TestDirB" $HWNDPARENT
	DetailPrint "SHFileCopy: $0"
	${StdUtils.SHFileMove} $0 "$PLUGINSDIR\TestDirA" "$PLUGINSDIR\SubDirY\TestDirC" $HWNDPARENT
	DetailPrint "SHFileMove: $0"
	ExecShell "explore" "$PLUGINSDIR"
SectionEnd

Section
	MessageBox MB_ICONINFORMATION "The next three operations are going to fail!$\nBut only one will be verbose..."

	${StdUtils.SHFileCopy} $0 "$PLUGINSDIR\TestDirXYZ" "$PLUGINSDIR\SubDirX\TestDirZ" $HWNDPARENT
	DetailPrint "SHFileCopy: $0"

	${StdUtils.SetVerbose} 1
	${StdUtils.SHFileCopy} $0 "$PLUGINSDIR\TestDirXYZ" "$PLUGINSDIR\SubDirX\TestDirZ" $HWNDPARENT
	DetailPrint "SHFileCopy: $0"

	${StdUtils.SetVerbose} 0
	${StdUtils.SHFileCopy} $0 "$PLUGINSDIR\TestDirXYZ" "$PLUGINSDIR\SubDirX\TestDirZ" $HWNDPARENT
	DetailPrint "SHFileCopy: $0"
SectionEnd</pre> <br> <a name="18e9c5cb"></a><h2>AppendToFile</h2> <p><b><tt>${StdUtils.AppendToFile} <i>user_var(output)</i> <i>from</i> <i>dest</i> <i>offset</i> <i>maxlen</i></tt></b></p> <p>Appends the contents of the existing <i>source</i> file specified by <tt>from</tt> to the <i>output</i> file specified by <tt>dest</tt>. If the output file does <i>not</i> exist yet, it will be created; otherwise the data is appended to the back-end of the existing file. Furthermore, <tt>offset</tt> specifies the number of bytes to be skipped in the source file, before the copying begins. If the <tt>offset</tt> is equal to or greater than the size of the source file, then <i>no</i> data is copied, which is <i>not</i> considered an error. Specify an <tt>offset</tt> of <b>0</b> in order to start copying right at the beginning of the source file. Finally, <tt>maxlen</tt> specifies the <i>maximum</i> number of bytes to be copied. Copying will stop when either the end of the source file is reached or when the specified maximum number of bytes have been copied. Set <tt>maxlen</tt> to <b>0</b>, if you want to copy the source file all the way to the end. If the function succeeds, it will return the number of bytes that have actually been copied. Note, however, that if more than <b>MAX_INT</b> (2,147,483,647) bytes have been copied, the return value will still be at most <b>MAX_INT</b>. If anything went wrong, e.g. a file could not be opened or a read/write operation failed, "error" is returned.</p> <p>Note: This function is implemented via native Win32 file I/O functions. It also uses a sufficiently large buffer (currently 8 KB) to speed up the copying process. This should be a lot faster than copying the data "byte by byte", using the built-in <i>FileReadByte</i> and <i>FileWriteByte</i> functions.</p> <pre>Section
	${StdUtils.AppendToFile} $0 "$EXEDIR\SourceFile1.bin" "$OUTDIR\OutputFile.bin" 0 0
	DetailPrint "AppendToFile: $0"

	${StdUtils.AppendToFile} $0 "$EXEDIR\SourceFile2.bin" "$OUTDIR\OutputFile.bin" 0 0
	DetailPrint "AppendToFile: $0"
SectionEnd</pre> <br> <a name="a3d3af46"></a><h2>Create Process Functions</h2> <p><b><tt>${StdUtils.ExecShellAsUser} <i>user_var(output)</i> <i>file</i> <i>verb</i> <i>args</i></tt></b></p> <p>The <tt>${StdUtils.ExecShellAsUser}</tt> function allows for launching a child process with normal user privileges (user level), directly from an elevated installer instance (admin level). This is in contrast to the built-in <tt>Exec</tt>, <tt>ExecWait</tt> and <tt>ExecShell</tt> instructions, which all cause the child process to be elevated too. Consequently, the <tt>${StdUtils.ExecShellAsUser}</tt> function provides a simple and more lightweight alternative to the UAC plug-in. The function expects three arguments: The path to the <tt>file</tt> to be executed, the <tt>verb</tt> that shall be used to execute the file (e.g. "open") and the argument string <tt>args</tt> to be passed to the new process. The last two arguments are optional and can be specified as <i>empty</i> strings (""). If the function succeeded, then it returns either "ok" or "fallback". Otherwise it returns either "einval", "timeout", "not_found" or "error".</p> <p>Please note that "einval" indicates that the function was called with invalid parameters, "not_found" indicates that the specified file doesn't exist, and "timeout" indicates that the function encountered a deadlock. Furthermore, note that "ok" indicates that the process was created using the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb774138%28v=vs.85%29.aspx">IShellDispatch2</a> COM interface, which is the <i>default</i> behaviour on modern systems (allows the new process to <i>not</i> be elevated), while "fallback" indicates that the normal <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb762153%28v=vs.85%29.aspx">ShellExecute()</a> method was used, which is the expected behaviour on legacy systems <i>without</i> UAC support.</p> <pre>!include 'StdUtils.nsh'

; make sure the installer will get elevated rights on UAC-enabled system (Vista+)
RequestExecutionLevel <span style="color:darkred">admin</span>
ShowInstDetails show

Section
	DetailPrint 'ExecShell: "$SYSDIR\mspaint.exe"'
	; this instance of MS Paint will be *elevated*, just like the installer!
	ExecShell "open" "$SYSDIR\mspaint.exe"
	MessageBox MB_TOPMOST "Close Paint and click 'OK' to continue..."
SectionEnd

Section
	DetailPrint 'ExecShellAsUser: "$SYSDIR\mspaint.exe"'
	Sleep 1000
	; now launch a *non-elevated* instance of MS Paint by using ExecShellAsUser
	${StdUtils.ExecShellAsUser} $0 "$SYSDIR\mspaint.exe" "open" ""
	; expected result is "ok" on UAC-enabled systems or "fallback" otherwise
	DetailPrint "Result: $0"
SectionEnd</pre> <p><br><b><tt>${StdUtils.ExecShellWaitEx} <i>user_var(output_1)</i> <i>user_var(output_2)</i> <i>file</i> <i>verb</i> <i>args</i><br>${StdUtils.WaitForProcEx} <i>user_var(output)</i> <i>handle</i></tt></b></p> <p>The <tt>${StdUtils.ExecShellWaitEx}</tt> function works like the built-in <tt>ExecShell</tt> command, except that you can wait for the process to terminate. The function expects three arguments: The path to the file to be executed, the <i>verb</i> that shall be used to execute the file (e.g. "open") and the arguments to be passed to the new process. The last two arguments are optional and can be specified as <i>empty</i> strings (""). Furthermore, the function returns two values: The <i>first</i> value is either "ok", "no_wait" or "error", while the <i>second</i> value provides additional info. "ok" indicates that the process was created successfully and can be waited for, "no_wait" indicates that we cannot wait for the process (because <tt>ShellExecuteEx</tt> did not create a new process, but passed the file/URL to a running instance) and "error" indicates that something went wrong.</p> <p>If the <i>first</i> return value is "ok", the <i>second</i> return value contains the handle of the new process. If the <i>first</i> return value is "error", the <i>second</i> return value contains the Win32 error code. And if the <i>first</i> return value is "no_wait", the <i>second</i> return value is zero. Only if "ok" <i>and</i> a process handle were returned, you can call <tt>${StdUtils.WaitForProcEx}</tt> in order to wait until the process has terminated. This means that you must <i>always</i> carefully check the <i>first</i> return value of <tt>${StdUtils.ExecShellWaitEx}</tt> before you pass the <i>second</i> return value to <tt>${StdUtils.WaitForProcEx}</tt>. The behavior of <tt>${StdUtils.WaitForProcEx}</tt> is undefined if you pass something that isn't a valid process handle! If successful, <tt>${StdUtils.WaitForProcEx}</tt> returns the exit code of the process after it has terminated. The function returns "error" if something went wrong.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	DetailPrint 'ExecShellWait: "$SYSDIR\mspaint.exe"'
	Sleep 1000
	${StdUtils.ExecShellWaitEx} $0 $1 "$SYSDIR\mspaint.exe" "open" "" ;try to launch the process

	DetailPrint "Result: $0 -> $1" ;returns "ok", "no_wait" or "error".
	StrCmp $0 "error" ExecFailed ;check if process failed to create
	StrCmp $0 "no_wait" WaitNotPossible ;check if process can be waited for - always check this!
	StrCmp $0 "ok" WaitForProc ;make sure process was created successfully
	Abort

	WaitForProc:
	DetailPrint "Waiting for process. ZZZzzzZZZzzz..."
	${StdUtils.WaitForProcEx} $2 $1
	DetailPrint "Process just terminated (exit code: $2)"
	Goto WaitDone

	ExecFailed:
	DetailPrint "Failed to create process (error code: $1)"
	Goto WaitDone

	WaitNotPossible:
	DetailPrint "Can not wait for process."
	Goto WaitDone

	WaitDone:
SectionEnd</pre> <br> <a name="f24cc3f9"></a><h2>Command-line Parameter Functions</h2> <p><b><tt>${StdUtils.TestParameter} <i>user_var(output)</i> <i>name</i><br>${StdUtils.GetParameter} <i>user_var(output)</i> <i>name</i> <i>default</i></tt></b></p> <p>With the <tt>${StdUtils.TestParameter}</tt> function you can check for the presence of the command-line parameter specified by <tt>name</tt>. If that parameter is present on the command-line, the function returns <tt>true</tt>, otherwise it returns <tt>false</tt>. Additionally, the <tt>${StdUtils.GetParameter}</tt> function can be used to get the value of the command-line parameter specified by <tt>name</tt>. If that parameter is present on the command-line, then the function returns the corresponding value. This might be an <i>empty</i> string! If the parameter is <i>not</i> present, then the <tt>default</tt> value is returned.</p> <p>Hint: If the same parameter appears on the command-line multiple times, only the <i>first</i> occurrence will be returned. If the parameter value is too long to fit into an NSIS string, it will be truncated as needed. In any case, the parameter value will automatically be <i>trimmed</i> by this function.</p> <p><b>Parameters are passed to the installer using the following syntax:</b></p> <ul> <li><tt>Installer.exe /ParameterName</tt> <li><tt>Installer.exe /ParameterName=Value</tt> <li><tt>Installer.exe --ParameterName</tt> <li><tt>Installer.exe --ParameterName=Value</tt> </ul> <p><b>If the value contains spaces, it needs to be wrapped in double quote (<tt>"</tt>) characters:</b></p> <ul> <li><tt>Installer.exe "/ParameterName=Value Containing Spaces"</tt> <li><tt>Installer.exe /ParameterName="Value Containing Spaces"</tt> <li><tt>Installer.exe /ParameterName=Value" Containing "Spaces</tt> </ul> <p>Note: The parameter <i>name</i> may contain any graphical characters, as defined by <a href="http://www.cplusplus.com/reference/cctype/isgraph/">isgraph()</a>, except for the equality character (<tt>=</tt>). Also, the parameter <i>name</i> must <u>not</u> start with a minus (<tt>-</tt>), slash (<tt>/</tt>) or backslash (<tt>\</tt>) character. The prefix, i.e. <tt>/</tt> or <tt>--</tt>, is <u>not</u> part of the parameter <i>name</i>!</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.TestParameter} $R0 "Foobar"
	StrCmp "$R0" "true" 0 +3
	DetailPrint 'Command-line parameter /Foobar is specified!'
	Goto +2
	DetailPrint 'Command-line parameter /Foobar is *not* specified!'
SectionEnd

Section
	${StdUtils.GetParameter} $R0 "Foobar" "&lt;MyDefault&gt;"
	DetailPrint 'Value of command-line parameter /Foobar is: "$R0"'
SectionEnd</pre> <p><b><tt><br>${StdUtils.ParameterCnt} <i>user_var(output)</i><br>${StdUtils.ParameterStr} <i>user_var(output)</i> <i>index</i></tt></b></p> <p>The <tt>${StdUtils.ParameterCnt}</tt> function returns then number of command-line tokens. This is equivalent to the <i>argc</i> parameter passed to the <a href="http://en.cppreference.com/w/cpp/language/main_function">main()</a> function. Note that this value may be <i>zero</i>, in which case <u>no</u> command-line tokens are available. If something went wrong, "error" is returned. Accordingly, the <tt>${StdUtils.ParameterStr}</tt> function returns the <i>n</i>-th command-line token. This is equivalent to the <i>n</i>-th element of the <i>argv</i> array passed to the <a href="http://en.cppreference.com/w/cpp/language/main_function">main()</a> function. Note that the token may be an <i>empty</i> string. Also note that this function uses <i>zero-based</i> indexing. Thus, an <tt>index</tt> of <b>0</b> returns the <i>first</i> token, an <tt>index</tt> of <b>1</b> returns the <i>second</i> token, and so on. The <tt>index</tt> must be in the <b>[0,N)</b> range (i.e. N <u>not</u> included), where <b>N</b> is the value returned by <tt>${StdUtils.ParameterCnt}</tt>. If something went wrong, e.g. <tt>index</tt> is out of range, the function returns "error".</p> <p>Hint: In contrast to the <a href="http://en.cppreference.com/w/cpp/language/main_function">main()</a> function, where the <i>first</i> token (index = 0) always contains the executable name, the <tt>${StdUtils.ParameterCnt}</tt> and <tt>${StdUtils.ParameterStr}</tt> functions will <u>omit</u> the executable name. Simply use the built-in <tt>$EXEFILE</tt> or <tt>$EXEPATH</tt> constants instead!</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	StrCpy $R0 0                                    #Init counter to zero
	${StdUtils.ParameterCnt} $R1                    #Get number of command-line tokens
	IntCmp $R1 0 0 0 LoopNext                       #Any tokens available?
	DetailPrint 'No command-line tokens!'           #Print some info
	Goto LoopExit                                   #Exit
LoopNext:
	${StdUtils.ParameterStr} $R2 $R0                #Read next command-line token
	DetailPrint 'Command-line token #$R0 is "$R2"'  #Print command-line token
	IntOp $R0 $R0 + 1                               #counter += 1
	IntCmp $R0 $R1 0 LoopNext                       #Loop while more tokens available
LoopExit:
SectionEnd</pre> <p><b><tt><br>${StdUtils.GetAllParameters} <i>user_var(output)</i> <i>truncate</i></tt></b></p> <p>Furthermore you can use <tt>${StdUtils.GetAllParameters}</tt> to get the <i>complete</i> command-line string, but <u>without</u> the executable name. This is useful, for example, to forward all command-line parameters to an <i><a href="http://nsis.sourceforge.net/Embedding_other_installers">embedded</a></i> installer. The <tt>truncate</tt> parameters controls the behavior of this function, if the command-line is too long to fit into an NSIS string. With <tt>truncate</tt> set to <b>1</b>, the command-line will be truncated to a length of <tt>NSIS_MAX_STRLEN</tt> characters. With <tt>truncate</tt> set to <b>0</b>, the function returns "too_long", if the command-line doesn't fit into an NSIS string.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.GetAllParameters} $R0 0
	DetailPrint "Complete command-line: '$R0'"

	${StdUtils.GetAllParameters} $R0 1
	DetailPrint "Truncated command-line: '$R0'"
SectionEnd</pre> <br> <a name="d452a779"></a><h2>InvokeShellVerb</h2> <p><b><tt>${StdUtils.InvokeShellVerb} <i>user_var(output)</i> <i>path</i> <i>file</i> <i>verb_id</i></tt></b></p> <p>The <tt>${StdUtils.InvokeShellVerb}</tt> function can be used to invoke a so-called "Shell Verb" on an arbitrary item. The most common use for this is (un)pinning an item to/from the Taskbar or the Startmenu, on Windows 7 and later. The function expects three arguments: The directory where the item (e.g. executable file or shortcut) is located, the name of the item, and the <i>id</i> of the shell verb to be invoked. We need the <i>id</i> of the verb, because the verb's name (string), which is used to select the desired verb from the list of available verbs, is <i>language-specific</i>; it depends on the Windows system language. However, we certainly do <b>not</b> want to make our installer specific to a certain system language. Resource id's, on the other hand, are <i>language-independent</i>. By using resource id's, we can load the actual verb name (string) <i>at runtime</i>. Note that while this function works on Windows 7 (and later) only, it still is perfectly safe to call on older versions of Windows. If the function succeeded, then it returns "ok"; if the function is called with invalid parameters, then it returns "einval"; if the requested verb could <i>not</i> be found, if the request verb is unavailable for the specified item, or if the specified item does <i>not</i> exist, then "not_found" will be returned; if this function is used on Windows versions prior to Windows 7 (e.g. Vista or XP), then it will return "unsupported"; and if the function failed for another reason, then it will return "error".</p> <p>Supported shell verbs IDs are:</p> <ul> <li><tt>${StdUtils.Const.ShellVerb.PinToTaskbar}</tt> <li><tt>${StdUtils.Const.ShellVerb.UnpinFromTaskbar}</tt> <li><tt>${StdUtils.Const.ShellVerb.PinToStart}</tt> <li><tt>${StdUtils.Const.ShellVerb.UnpinFromStart}</tt> </ul> <p>Hint: If you are getting the "not_found" error for a verb that is supposed to exists, then it's probably because the desired action isn't currently available for the item (e.g. it could be that you are trying to pin an item that already is pinned).</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user ;no elevation needed for this test
ShowInstDetails show

Section
	IfFileExists "$SYSDIR\mspaint.exe" +3
	MessageBox MB_ICONSTOP 'File does not exist:$\n"$SYSDIR\mspaint.exe"$\n$\nExample cannot run!'
	Quit
SectionEnd

Section
	DetailPrint "Going to pin MSPaint..."
	${StdUtils.InvokeShellVerb} $0 "$SYSDIR" "mspaint.exe" ${StdUtils.Const.ShellVerb.PinToTaskbar}
	DetailPrint "Result: $0"

	StrCmp "$0" "ok" 0 +3
	MessageBox MB_TOPMOST "Paint should have been pinned to Taskbar now!"
	Goto +2
	MessageBox MB_TOPMOST "Failed to pin, see log for details!"
SectionEnd

Section
	DetailPrint "Going to un-pin MSPaint..."
	${StdUtils.InvokeShellVerb} $0 "$SYSDIR" "mspaint.exe" ${StdUtils.Const.ShellVerb.UnpinFromTaskbar}
	DetailPrint "Result: $0"

	StrCmp "$0" "ok" 0 +3
	MessageBox MB_TOPMOST "Paint should have been un-pinned from Taskbar now!"
	Goto +2
	MessageBox MB_TOPMOST "Failed to un-pin, see log for details!"
SectionEnd</pre> <br> <a name="f57ec206"></a><h2>OS Version Functions</h2> <p><b><tt>${StdUtils.GetRealOSVersion} <i>user_var(out_major)</i> <i>user_var(out_minor)</i> <i>user_var(out_spack)</i></tt></b></p> <p>The <tt>${StdUtils.GetRealOSVersion}</tt> function returns the <i>real</i> <a href="#b26a3e82">Windows NT version</a> installed on the computer. Note that starting with Windows 8.1 (Windows NT 6.3), Microsoft has <u>broken</u> the <tt>GetVersion()</tt> and <tt>GetVersionEx()</tt> functions! These function will now return the Windows version that the calling application has been compiled for (as indicated by the program's <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd371711%28v=vs.85%29.aspx">Compat Manifest</a>), <b>not</b> the actual Windows version that we are running on! So these functions are effectively a NOP now &ndash; you don't need to call the Win32 API to determine which Windows version your own program has been compiled for, as you already know it. This has the consequence that Windows 8.1 and Windows 10 will now identify themselves as Windows 8.0, unless the calling application has been specifically compiled for Windows 8.1 or 10. Bummer!</p> <p>Workarounds to "reveal" the actual Windows version exist. For example, one may try <i>guestimating</i> the real Windows version from certain Registry entries or from the file versions of certain system libraries. But, while these methods may seem to work in most cases, they still are <i>dubious</i>. It is also possible to obtain the real Windows version via WMI (Windows Management Instrumentation), but this is complex and requires a lot of COM hackery. At the same time, the provided <tt>${StdUtils.GetRealOSVersion}</tt> function manages to reveal the <u>actual</u> Windows version strictly by using "official" Win32 API calls. Also, this function works regardless of the application Manifest, i.e. it will continue to work correctly in <i>future</i> Windows versions! Finally, this function still returns the <u>correct</u> Windows version, when the installer runs in "compatibility mode".</p> <p>The function will return the <i>major</i> and <i>minor</i> Windows NT version (e.g. "6.3" on Windows 8.1, or "10.0" on Windows 10) plus the corresponding Service Pack version <i>spack</i>. It returns "error", if something went wrong.</p> <p>Note: This function uses an iterative approach: It first calls <tt>GetVersionEx()</tt> to get the "fake" Windows version. Then it tries to <i>refine</i> the Windows version, step by step, using the <tt>VerifyVersionInfo()</tt> function - until the "real" version has been revealed. Furthermore, because the <tt>VerifyVersionInfo()</tt> function has been broken too on Windows 10 (facepalm!), we now try to call the "native" functions <tt>RtlGetVersion()</tt> and <tt>RtlVerifyVersion()</tt> directly from NTDLL.DLL, instead of using the "crippled" counterparts from KERNEL32.DLL.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.GetRealOSVersion} $1 $2 $3
	DetailPrint "Real Windows NT Version: $1,$2 (Service Pack: $3)"
SectionEnd</pre> <p><br><b><tt>${StdUtils.GetRealOSBuildNo} <i>user_var(out)</i></tt></b></p> <p>The <tt>${StdUtils.GetRealOSBuildNo}</tt> function returns the <i>real</i> <a href="#b26a3e82">Windows NT build number</a> installed on the computer. The function will return the Windows NT build number (e.g. "7600" on Windows 7 RTM). It returns "error", if something went wrong.</p> <p>Note: This function uses the same algorithm as <tt>${StdUtils.GetRealOSVersion}</tt> to determine the <i>real</i> Windows build number, so it will give the expected result on Windows 8.1 and later.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.GetRealOSBuildNo} $1
	DetailPrint "Real Windows NT Build No.: $1"
SectionEnd</pre> <p><br><b><tt>${StdUtils.GetRealOSName} <i>user_var(out)</i></tt></b></p> <p><tt>${StdUtils.GetRealOSName}</tt> is a convenience function that returns the installed Windows version as a <a href="#b26a3e82">friendly name</a> string. Currently the return value can be "Windows NT 4.0", "Windows 2000", "Windows XP", "Windows XP (x64)", "Windows Vista", "Windows 7", "Windows 8", "Windows 8.1", "Windows 10" or any corresponding server edition. If an <i>unknown</i> Windows version is encountered, e.g. some future version that is not yet supported, the function will return "unknown". And it will return "error", if something else went wrong.</p> <p>Note: This function uses the same algorithm as <tt>${StdUtils.GetRealOSVersion}</tt> and <tt>${StdUtils.GetOSEdition}</tt>to determine the <i>real</i> Windows version. The <i>real</i> version will be converted to a friendly name, so it will give the expected result on Windows 8.1 and later.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.GetRealOSName} $1
	DetailPrint "Real Windows NT Friendly Name: $1"
SectionEnd</pre> <p><br><b><tt>${StdUtils.VerifyOSVersion} <i>user_var(out)</i> <i>expected_major</i> <i>expected_minor</i> <i>expected_spack</i></tt></b></p> <p><tt>${StdUtils.VerifyOSVersion}</tt> is a convenience function to compare the installed Windows version against some expected one. The expected <a href="#b26a3e82">Windows NT version</a> (e.g. "6.2" for Windows 8.0) is specified by the <tt>expected_major</tt>, <tt>expected_minor</tt> and <tt>expected_spack</tt> parameters. The function returns "ok" when the installed Windows version matches the expected one <i>exactly</i>; it returns "older" when the installed version is <i>older</i> than expected; it returns "newer" when the installed version is <i>newer</i> than expected; and it returns "error" if something went wrong.</p> <p>Note: This function uses the same algorithm as <tt>${StdUtils.GetRealOSVersion}</tt> to determine the <i>real</i> Windows version that will be compared to the expected version, so it will give the expected result on Windows 8.1 and later.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.VerifyOSVersion} $1 5 1 0
	DetailPrint "Check for Windows XP (RTM): $1"

	${StdUtils.VerifyOSVersion} $1 5 1 3
	DetailPrint "Check for Windows XP (SP3): $1"

	${StdUtils.VerifyOSVersion} $1 6 1 0
	DetailPrint "Check for Windows 7 (RTM): $1"

	${StdUtils.VerifyOSVersion} $1 6 1 1
	DetailPrint "Check for Windows 7 (SP1): $1"

	${StdUtils.VerifyOSVersion} $1 6 2 0
	DetailPrint "Check for Windows 8.0: $1"

	${StdUtils.VerifyOSVersion} $1 6 3 0
	DetailPrint "Check for Windows 8.1: $1"
SectionEnd</pre> <p><br><b><tt>${StdUtils.VerifyOSBuildNo} <i>user_var(out)</i> <i>expected_build</i></tt></b></p> <p><tt>${StdUtils.VerifyOSBuildNo}</tt> is a convenience function to compare the installed Windows version against some expected version. The expected <a href="#b26a3e82">Windows NT build number</a> is specified by <tt>expected_build</tt> (e.g. "7600" on Windows 7 RTM). The function will return "ok" when the installed Windows build matches the expected one <i>exactly</i>; it returns "older" when the installed build is <i>older</i> than the expected one; it returns "newer" when the installed version is <i>newer</i> than the expected one; and it returns "error" if something went wrong.</p> <p>Note: This function uses the same algorithm as <tt>${StdUtils.GetRealOSVersion}</tt> to determine the <i>real</i> Windows build number that will be compared to the expected build number, so it will give the expected result on Windows 8.1 and later.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.VerifyOSBuildNo} $1 2600
	DetailPrint "Check for Build #2600, Windows XP: $1"

	${StdUtils.VerifyOSBuildNo} $1 7600
	DetailPrint "Check for Build #7600, Windows 7 (RTM): $1"

	${StdUtils.VerifyOSBuildNo} $1 7601
	DetailPrint "Check for Build #7601, Windows 7 (SP1): $1"

	${StdUtils.VerifyOSBuildNo} $1 9600
	DetailPrint "Check for Build #9600, Windows 8.1: $1"
SectionEnd</pre> <p><br><b><tt>${StdUtils.GetOSEdition} <i>user_var(out)</i></tt></b></p> <p><tt>${StdUtils.GetOSEdition}</tt> returns the Windows edition, i.e. either "workstation" or "server". It returns "error" if something went wrong.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.GetOSEdition} $1
	DetailPrint "Windows Edition is: $1"
SectionEnd</pre> <br> <a name="b26a3e82"></a><p><b>List of Windows NT versions:</b></p> <table border> <tr><td><b>Friendly Name</b></td><td><b>Server Edition</b></td><td><b>NT Version</b></td><td><b>Build No.</b></td></tr> <tr><td>Windows NT 4.0</td><td>-</td><td><tt>4.0</tt></td><td><tt>1381</tt></td></tr> <tr><td>Windows 2000</td><td>-</td><td><tt>5.0</tt></td><td><tt>2195</tt></td></tr> <tr><td>Windows XP</td><td>-</td><td><tt>5.1</tt></td><td><tt>2600</tt></td></tr> <tr><td>Windows XP (x64)</td><td>Windows Server 2003</td><td><tt>5.2</tt></td><td><tt>3790</tt></td></tr> <tr><td>Windows Vista</td><td>Windows Server 2008</td><td><tt>6.0</tt></td><td><tt>6000</tt> - <tt>6002</tt></td></tr> <tr><td>Windows 7</td><td>Windows Server 2008 R2</td><td><tt>6.1</tt></td><td><tt>7600</tt> - <tt>7601</tt></td></tr> <tr><td>Windows 8</td><td>Windows Server 2012</td><td><tt>6.2</tt></td><td><tt>9200</tt></td></tr> <tr><td>Windows 8.1</td><td>Windows Server 2012 R2</td><td><tt>6.3</tt></td><td><tt>9600</tt></td></tr> <tr><td>Windows 10</td><td>Windows Server 2016</td><td><tt>10.0</tt></td><td><tt>10240-14393</tt></td></tr> </table> <br><br> <a name="e1f7e07b"></a><h2>Cryptographic Hash Functions</h2> <p><b><tt>${StdUtils.HashText} <i>user_var(out)</i> <i>type</i> <i>text</i></tt></b></p> <p>The <tt>${StdUtils.HashText}</tt> function computes the <i>cryptographic hash</i> of the message given by <tt>text</tt>, using the hash function specified by <tt>type</tt>. Currently CRC32, MD5, SHA-1, the SHA-2 family as well as the SHA-3 family are supported (using <a href="https://github.com/rhash/RHash">RHash</a> implementation). See below for details! If the function succeeds, it will return the hash value, as a <i>hexadecimal</i> string. The length of the result depends on the chosen hash function. If an invalid hash function was specified, the function returns "invalid". And, if anything else went wrong, it returns "error".</p> <p>Note: For improved consistency between the ANSI and Unicode installers, the Unicode version of this function will convert the given message to <i>UTF-8</i> before hash computation!</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.HashText} $0 "SHA3-224" "The quick brown fox jumps over the lazy dog"
	DetailPrint 'SHA3-224("The quick brown fox jumps over the lazy dog") = "$0"'

	${StdUtils.HashText} $0 "SHA3-256" "The quick brown fox jumps over the lazy dog"
	DetailPrint 'SHA3-256("The quick brown fox jumps over the lazy dog") = "$0"'

	${StdUtils.HashText} $0 "SHA3-384" "The quick brown fox jumps over the lazy dog"
	DetailPrint 'SHA3-384("The quick brown fox jumps over the lazy dog") = "$0"'

	${StdUtils.HashText} $0 "SHA3-512" "The quick brown fox jumps over the lazy dog"
	DetailPrint 'SHA3-512("The quick brown fox jumps over the lazy dog") = "$0"'
SectionEnd</pre> <p><br><b><tt>${StdUtils.HashFile} <i>user_var(out)</i> <i>type</i> <i>path</i></tt></b></p> <p>The <tt>${StdUtils.HashText}</tt> function computes the <i>cryptographic hash</i> of the contents of the file specified by <tt>path</tt>, using the hash function specified by <tt>type</tt>. Currently CRC32, MD5, SHA-1, the SHA-2 family as well as the SHA-3 family are supported (using <a href="https://github.com/rhash/RHash">RHash</a> implementation). See below for details! If the function succeeds, it will return the hash value, as a <i>hexadecimal</i> string. The length of the result depends on the chosen hash function. If an invalid hash function was specified, the function returns "invalid". And, if anything else went wrong, it returns "error".</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.HashFile} $0 "SHA3-224" "$WINDIR\Explorer.exe"
	DetailPrint 'SHA3-224($WINDIR\Explorer.exe) = "$0"'

	${StdUtils.HashFile} $0 "SHA3-256" "$WINDIR\Explorer.exe"
	DetailPrint 'SHA3-256($WINDIR\Explorer.exe) = "$0"'

	${StdUtils.HashFile} $0 "SHA3-384" "$WINDIR\Explorer.exe"
	DetailPrint 'SHA3-384($WINDIR\Explorer.exe) = "$0"'

	${StdUtils.HashFile} $0 "SHA3-512" "$WINDIR\Explorer.exe"
	DetailPrint 'SHA3-512($WINDIR\Explorer.exe) = "$0"'
SectionEnd</pre> <br> <p><b>List of supported hash functions:</b></p> <table border> <tr><td><b>Hash Function</b></td><td><b>Hash Length in Bit (in Byte)</b></td><td><b>Algorithm Identifier</b></td></tr> <tr><td>CRC<b style="color:red">*</b></td><td>32 (4)</td><td><tt>CRC-32</tt></td></tr> <tr><td>MD5<b style="color:red">*</b></td><td>128 (16)</td><td><tt>MD5-128</tt></td></tr> <tr><td>SHA-1<b style="color:red">*</b></td><td>160 (20)</td><td><tt>SHA1-160</tt></td></tr> <tr><td rowspan="4">SHA-2</td><td>224 (28)</td><td><tt>SHA2-224</tt></td></tr> <tr><td>256 (32)</td><td><tt>SHA2-256</tt></td></tr> <tr><td>384 (48)</td><td><tt>SHA2-384</tt></td></tr> <tr><td>512 (64)</td><td><tt>SHA2-512</tt></td></tr> <tr><td rowspan="4">SHA-3</td><td>224 (28)</td><td><tt>SHA3-224</tt></td></tr> <tr><td>256 (32)</td><td><tt>SHA3-256</tt></td></tr> <tr><td>384 (48)</td><td><tt>SHA3-384</tt></td></tr> <tr><td>512 (64)</td><td><tt>SHA3-512</tt></td></tr> <tr><td rowspan="4">BLAKE2</td><td>224 (28)</td><td><tt>BLAKE2-224</tt></td></tr> <tr><td>256 (32)</td><td><tt>BLAKE2-256</tt></td></tr> <tr><td>384 (48)</td><td><tt>BLAKE2-384</tt></td></tr> <tr><td>512 (64)</td><td><tt>BLAKE2-512</tt></td></tr> </table> <p><small><b style="color:red">*</b> Please do <u>not</u> use these hash functions for security critical code nowadays, as they they have known collisions!</small></p> <br> <a name="fe8b67bc"></a><h2>Path Utility Functions</h2> <p><b><tt>${StdUtils.NormalizePath} <i>user_var(out)</i> <i>path</i></tt></b></p> <p>The <tt>${StdUtils.NormalizePath}</tt> function <i>normalizes</i> the given path. The function will remove any navigation elements (such as <tt>.</tt> or <tt>..</tt>) in order to produce a direct, well-formed path. Also, if a <i>relative</i> path is given the function, that path will be expanded to an <i>absolute</i> path, based on the current working directory. Furthermore, any forward slash (<tt>/</tt>) in the path will be replaced by a backslash (<tt>\</tt>). Last but not least, multiple backslash characters in a row will be replaced by a single backslash character and any <i>trailing</i> backslash characters are removed.</p> <p>This function does <i>not</i> care whether the given path points to a file or to a directory. The given path does <i>not</i> need to point to an existing file-system object. The function does <i>not</i> check whether the target file-system object exists. If the function fails, an empty string (<tt>""</tt>) will be returned.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	StrCpy $0 "C:\Foo\\Bar/Test\.\..\Test\."
	${StdUtils.NormalizePath} $1 "$0"
	DetailPrint 'NormalizePath: "$0" -> "$1"'
SectionEnd</pre> <p><br><b><tt>${StdUtils.GetParentPath} <i>user_var(out)</i> <i>path</i></tt></b></p> <p>The <tt>${StdUtils.GetParentPath}</tt> function returns the <i>parent</i> path of the given path. If the given path points to a <i>file</i>, the function will return the path of directory where the file is located. If the given path points to a <i>directory</i>, the function will return the path of the directory that is located one level above the given directory. In any case, the given path will first be <i>normalized</i>, according to the <tt>${StdUtils.NormalizePath}</tt> function, and then the <i>last</i> (rightmost) path-component will be chopped off.</p> <p>The given path does <i>not</i> need to point to an existing file-system object. The function does <i>not</i> check whether the target file-system object exists. If the function fails, an empty string (<tt>""</tt>) will be returned. If the given path already points to the drive's <i>root</i> directory, the function will fail.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	StrCpy $0 "C:\Foo\Bar\Test\Honk\Sponk"
DoLoop:
	${StdUtils.GetParentPath} $1 "$0"
	DetailPrint 'GetParentPath: "$0" -> "$1"'
	StrCpy $0 "$1"
	StrCmp "$0" "" 0 DoLoop
SectionEnd</pre> <p><br><b><tt>${StdUtils.SplitPath} <i>user_var(out_drive)</i> <i>user_var(out_dir)</i> <i>user_var(out_fname)</i> <i>user_var(out_ext)</i> <i>path</i></tt></b></p> <p>The <tt>${StdUtils.SplitPath}</tt> function splits the given path into the separate components. These components are <i>drive letter</i>, <i>directory path</i>, <i>file name</i>, and <i>file extension</i>. Each component is returned separately.</p> <p>The given path does <i>not</i> need to point to an existing file-system object. The function does <i>not</i> check whether the target file-system object exists. If a certain component is missing in the given path, an empty string (<tt>""</tt>) will be returned for that component.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	StrCpy $0 "C:\Windows\System32\kernel32.dll"
	${StdUtils.SplitPath} $1 $2 $3 $4 "$0"
	DetailPrint 'SplitPath [1]: "$0" -> "$1"' # "C:"
	DetailPrint 'SplitPath [2]: "$0" -> "$2"' # "\Windows\System32\"
	DetailPrint 'SplitPath [3]: "$0" -> "$3"' # "kernel32"
	DetailPrint 'SplitPath [4]: "$0" -> "$4"' # ".dll"
SectionEnd</pre> <p><br><b><tt>${StdUtils.GetDrivePart} <i>user_var(out)</i> <i>path</i><br>${StdUtils.GetDirectoryPart} <i>user_var(out)</i> <i>path</i><br>${StdUtils.GetFileNamePart} <i>user_var(out)</i> <i>path</i><br>${StdUtils.GetExtensionPart} <i>user_var(out)</i> <i>path</i></tt></b></p> <p>The <tt>${StdUtils.GetDrivePart}</tt>, <tt>${StdUtils.GetDirectoryPart}</tt>, <tt>${StdUtils.GetFileNamePart}</tt> and <tt>${StdUtils.GetExtensionPart}</tt> functions return the <i>drive letter</i>, <i>directory path</i>, <i>file name</i>, and <i>file extension</i> component of the given path, respectively.</p> <p>The given path does <i>not</i> need to point to an existing file-system object. The function does <i>not</i> check whether the target file-system object exists. If a certain component is missing in the given path, an empty string (<tt>""</tt>) will be returned for that component.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	${StdUtils.GetDrivePart} $1 "C:\Windows\System32\kernel32.dll"
	DetailPrint 'GetDrivePart: "$1"'     # "C:"
	
	${StdUtils.GetDirectoryPart} $1 "C:\Windows\System32\kernel32.dll"
	DetailPrint 'GetDirectoryPart: "$1"' # "\Windows\System32\"
	
	${StdUtils.GetFileNamePart} $1 "C:\Windows\System32\kernel32.dll"
	DetailPrint 'GetFileNamePart: "$1"'  # "kernel32"
	
	${StdUtils.GetExtensionPart} $1 "C:\Windows\System32\kernel32.dll"
	DetailPrint 'GetExtensionPart: "$1"' # ".dll"
SectionEnd</pre> <br> <a name="fe7af29a"></a><h2>Cryptographic Functions</h2> <p><b><tt>${StdUtils.ProtectStr} <i>user_var(out)</i> <i>dpsc</i> <i>salt</i> <i>text</i><br>${StdUtils.UnprotectStr} <i>user_var(out)</i> <i>trnc</i> <i>salt</i> <i>data</i></tt></b></p> <p>The <tt>${StdUtils.ProtectStr}</tt> function protects (encrypts) the given <tt>text</tt> string using the <a href="https://msdn.microsoft.com/en-us/library/ms995355.aspx">DPAPI</a> (Windows Data Protection). The <tt>dpsc</tt> parameter can be set to "CU" (current user) or "LM" (local machine), which will encrypt the string in such a way that it can <i><b>only</b></i> be decrypted again by the <i>current user</i> or on the <i>local machine</i>, respectively. The <i>optional</i> <tt>salt</tt> parameter can be used to pass a user-defined salt value; pass an empty string ("") in order to <i>disable</i> the user-defined salt. If a user-defined salt value is passed, it will be used as <i>additional</i> entropy to encrypt the input string. In that case, the exactly same salt value must be passed again in order to decrypt the string! On success, the encrypted data is returned as a <a href="https://en.wikipedia.org/wiki/Base64">Base64</a>-encoded string. If invalid parameters have been passed, then "einval" is returned; if the string could <i>not</i> be encrypted (DPAPI error), then "encr_failed" is returned; if the length of the encoded data exceeds the maximum NSIS string length, then "too_long" is returned; and if other errors have occurred, then "error" is returned. Furthermore, if anything went wrong, the the error flag is set.</p> <p>The <tt>${StdUtils.UnprotectStr}</tt> function unprotects (decrypts) the given encrypted <tt>data</tt> using the DPAPI. The encrypted data is expected to be passed as a Base64-encoded string. The <tt>trnc</tt> parameter controls the behavior of the function, in case that the length of the decrypted string exceeds the maximum NSIS string length: If the parameter is set to <tt>1</tt>, then the string is truncated; if the parameter is set to <tt>0</tt>, then the function fails. The <tt>salt</tt> parameter can be used to pass a user-defined salt value. If the string has been encrypted using a user-defined salt, then the exactly same salt value must be passed here again; if <i>no</i> user-defined salt has been used to encrypt the string, then an empty string ("") must be passed. On success, the function returns the plaintext string. If invalid parameters have been passed, then "einval" is returned; if the string could <i>not</i> be encrypted (DPAPI error), then "decr_failed" is returned; if the length of the encoded data exceeds the maximum NSIS string length, then "too_long" is returned; and if other errors have occurred, then "error" is returned. Furthermore, if anything went wrong, the the error flag is set.</p> <p><i>Note:</i> <tt>ProtectStr</tt> converts the given plaintext string from UTF-16 (Unicode version) or from the current ANSI codepage (ANSI version) to a NULL-terminated UTF-8 byte sequence. The resulting UTF-8 bytes are then encrypted using the DPAPI. Accordingly, <tt>UnprotectStr</tt> interprets the decrypted bytes returned by the DPAPI as an UTF-8 sequence. The UTF-8 sequence is expected to be NULL-terminated! The function then converts the UTF-8 sequence to either UTF-16 (Unicode version) or to the current ANSI codepage (ANSI version). <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Section
	ClearErrors
	
	${StdUtils.ProtectStr} $1 "CU" "a7gzLbdwdbk4" "Five quacking Zephyrs jolt my wax bed."
	DetailPrint 'ProtectedStr: "$1"'
	
	IfErrors 0 +3
	DetailPrint "Whoops, encryption has failed!"
	Abort
	
	${StdUtils.UnprotectStr} $2 0 "a7gzLbdwdbk4" "$1"
	DetailPrint 'UnprotectedStr: "$2"'
	
	IfErrors 0 +3
	DetailPrint "Whoops, decryption has failed!"
	Abort
SectionEnd</pre> <a name="5247e2cd"></a><h2>Window Timer Functions</h2> <p><b><tt>${StdUtils.TimerCreate} <i>user_var(out)</i> <i>callback</i> <i>interval</i><br>${StdUtils.TimerDestroy} <i>user_var(out)</i> <i>timer_id</i></tt></b></p> <p>The <tt>${StdUtils.TimerCreate}</tt> function creates a new window timer, using the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644906%28v=vs.85%29.aspx">SetTimer</a> API, which is going to <i>periodically</i> execute the NSIS function specified by <tt>callback</tt>. The interval (delay), in milliseconds, is specified by <tt>interval</tt>. If the timer was created successfully, the function returns a <i>unique</i> timer id. And, if anything went wrong, it returns "error". The <tt>${StdUtils.TimerDestroy}</tt> function stops and destroys the timer specified by <tt>timer_id</tt>. Every timer that has been created successfully <b>must</b> be destroyed before the installer unloads the plug-in DLL!</p> <p><b>Important:</b> The <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644906%28v=vs.85%29.aspx">SetTimer</a> function works by appending <tt>WM_TIMER</tt> messages to the <i>message queue</i> of the thread which has created the timer. These messages will be <a href="https://msdn.microsoft.com/de-de/library/windows/desktop/ms644934%28v=vs.85%29.aspx">dispatched</a> to the <i>window procedure</i>, which eventually calls the callback function (TIMERPROC). Consequently, the thread, which creates the timer, <i>must</i> be running a <a href="https://en.wikipedia.org/wiki/Message_loop_in_Microsoft_Windows">message loop</a> &ndash; otherwise the timer is <i>never</i> going to fire! For NSIS this means that the timer must be created (and destroyed) from the "main" GUI thread. You probably want to do this in the <b>.onGUIInit</b> and <b>.onGUIEnd</b> functions.</p> <pre>!include 'StdUtils.nsh'

RequestExecutionLevel user
ShowInstDetails show

Var TimerId
Var MyCount

Function MyCallback
	IntOp $MyCount $MyCount + 1
	DetailPrint "Timer event has been triggered! (#$MyCount)"
FunctionEnd

Function .onGUIInit
	${StdUtils.TimerCreate} $TimerId MyCallback 1500
	StrCmp $TimerId "error" 0 +2
	MessageBox MB_ICONSTOP "Failed to create timer!"
FunctionEnd

Function .onGUIEnd
	StrCmp $TimerId "error" 0 +2
	Return
	${StdUtils.TimerDestroy} $0 $TimerId
	StrCmp $0 "ok" +2
	MessageBox MB_ICONSTOP "Failed to destroy timer!"
FunctionEnd

Section
	DetailPrint "Hello, world!"
SectionEnd</pre> <br> <a name="14863bf9"></a><h2>Debugging Functions</h2> <p><b><tt>${StdUtils.GetLibVersion} <i>user_var(out_ver)</i> <i>user_var(out_tst)</i></tt></b></p> <p>The <tt>${StdUtils.GetLibVersion}</tt> function returns the version of the StdUtils library that is being used. The version string (in the "w.x.y.z" format) is returned in <tt>out_ver</tt>; the build time-stamp is returned in <tt>out_tst</tt>.</p> <br style="margin: -0.5em"> <p><b><tt>${StdUtils.SetVerbose} <i>on</i></tt></b></p> <p>The <tt>${StdUtils.SetVerbose}</tt> function enables or disables verbose error messages. Set <tt>on</tt> to '1' to <i>enable</i> verbose outputs or set it to '0' to <i>disable</i> verbose outputs. Verbose outputs are <i>disabled</i> by default. Do <b>not</b> enabled them for <i>release</i> versions of your installer!</p> <br> <a name="db579654"></a><h1>License</h1> <p>The <b>StdUtils</b> plug-in for NSIS was created by LoRd_MuldeR &lt;mulder2@gmx.de&gt;. It is distributed under the <b><a href="https://www.gnu.org/licenses/lgpl-2.1.html">GNU LGPL v2.1</a></b>.</p> <pre>StdUtils plug-in for NSIS
Copyright (C) 2004-2018 LoRd_MuldeR &lt;mulder2@gmx.de&gt;

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.</pre> <p>The author of the StdUtils plug-in Library for NSIS adds the following clarification to the GNU Lesser General Public License version 2.1: Installer programs (executables) created with NSIS (Nullsoft Scriptable Install System) that make use of the StdUtils plug-in Library (strictly through the NSIS plug-in interface) and that contain/distribute verbatim copies of the StdUtils plug-in Library are considered a "work that uses the Library"; they do <b>not</b> represent a derivative of the Library.</p> <br> <a name="b92197af"></a><h1>Acknowledgment</h1> <p>This plug-in has been inspired, partly, by the <b>InvokeShellVerb</b> plug-in, created by <i>Robert Strong</i>.</p> <p>This plug-in has been inspired, partly, by the <b>ShellExecAsUser</b> plug-in, created by <i>installer32</i>.</p> <p>Special thanks to <i>Afrow UK</i> for providing his excellent plug-ins (his code helped me to understand how to write NSIS plug-ins).</p> <p><br>The following third-party code has been incorporated into StdUtils plug-in: <ul> <li><p><b>RHash</b><br> <i>Copyright (c) 2005-2014 Aleksey Kravchenko &lt;rhash.admin&#64;gmail.com&gt;</i><br> <a href="https://github.com/rhash/RHash">https://github.com/rhash/RHash</a></p> <pre>Permission is hereby granted, free of charge,  to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction,  including without limitation the rights
to  use,  copy,  modify,  merge, publish, distribute, sublicense, and/or sell
copies  of  the Software,  and  to permit  persons  to whom  the Software  is
furnished to do so.
The Software  is distributed in the hope that it will be useful,  but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  Use  this  program  at  your  own  risk!</pre> <li><p><b>BLAKE2 reference source code package</b><br> <i>Written in 2012 by Samuel Neves &lt;sneves@dei.uc.pt&gt;</i><br> <a href="https://github.com/BLAKE2/BLAKE2">https://github.com/BLAKE2/BLAKE2</a></p> <pre>To the extent possible under law, the author(s) have dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.
You should have received a copy of the CC0 Public Domain Dedication along with
this software. If not, see &lt;http://creativecommons.org/publicdomain/zero/1.0/&gt;.</pre> <li><p><b>Base64 encoder/decoder, originally from Apache</b><br> <i>Copyright (c) 1995-1999 The Apache Group. All rights reserved.</i><br> <a href="http://httpd.apache.org/">http://httpd.apache.org/</a></p> <pre>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

3. All advertising materials mentioning features or use of this
   software must display the following acknowledgment:
   "This product includes software developed by the Apache Group
   for use in the Apache HTTP server project (http://www.apache.org/)."

4. The names "Apache Server" and "Apache Group" must not be used to
   endorse or promote products derived from this software without
   prior written permission. For written permission, please contact
   apache@apache.org.

5. Products derived from this software may not be called "Apache"
   nor may "Apache" appear in their names without prior written
   permission of the Apache Group.

6. Redistributions of any form whatsoever must retain the following
   acknowledgment:
   "This product includes software developed by the Apache Group
   for use in the Apache HTTP server project (http://www.apache.org/)."

THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
OF THE POSSIBILITY OF SUCH DAMAGE.
====================================================================

This software consists of voluntary contributions made by many
individuals on behalf of the Apache Group and was originally based
on public domain software written at the National Center for
Supercomputing Applications, University of Illinois, Urbana-Champaign.
For more information on the Apache Group and the Apache HTTP server
project, please see &lt;http://www.apache.org/&gt;.</pre> </ul> <br> <a name="01efe0f2"></a><h1>Download and Sources</h1> <p>The source codes for the StdUtils plug-in are available from the code repository at:</p> <ul> <li><tt>https://github.com/lordmulder/stdutils.git</tt> (<a href="https://github.com/lordmulder/stdutils">Browse</a> | <a href="https://github.com/lordmulder/stdutils/commits/master">History</a>) <li><tt>https://gitlab.com/stdutils-plug-in-for-nsis/stdutils-plug-in-for-nsis.git</tt> (<a href="https://gitlab.com/stdutils-plug-in-for-nsis/stdutils-plug-in-for-nsis/tree/master">Browse</a> | <a href="https://gitlab.com/stdutils-plug-in-for-nsis/stdutils-plug-in-for-nsis/commits/master">History</a>) <li><tt>https://bitbucket.org/muldersoft/stdutils.git</tt> (<a href="https://bitbucket.org/muldersoft/stdutils/src">Browse</a> | <a href="https://bitbucket.org/muldersoft/stdutils/commits">History</a>) </ul> <p><br>You can download pre-compiled binaries (i.e. ready-to-use DLL files) of the plug-in from here:</p> <ul> <li><a href="https://github.com/lordmulder/stdutils/releases/latest">https://github.com/lordmulder/stdutils/releases/latest</a> <li><a href="http://sourceforge.net/projects/muldersoft/files/StdUtils-Plugin%20%28NSIS%29/">http://sourceforge.net/projects/muldersoft/files/StdUtils-Plugin%20%28NSIS%29/</a> <li><a href="https://bitbucket.org/muldersoft/stdutils/downloads/">https://bitbucket.org/muldersoft/stdutils/downloads/</a> <li><a href="https://www.mediafire.com/folder/ixmdy3afe7673/StdUtils-Plugin">https://www.mediafire.com/folder/ixmdy3afe7673/StdUtils-Plugin</a> </ul> <br> <a name="8d7f91f6"></a><h1>Help & Support</h1> <p>For help and support, please use the "NSIS Discussion" sub-forum of the Winamp forums:<br> <a href="http://forums.winamp.com/forumdisplay.php?f=65">http://forums.winamp.com/forumdisplay.php?f=65</a></p> <p>If you have any <i>feature requests</i> or <i>bug reports</i>, please submit them directly to our GitHub bug-tracker:<br> <a href="https://github.com/lordmulder/stdutils/issues">https://github.com/lordmulder/stdutils/issues</a></p> <p>Also you may wish to check the official NSIS Wiki for the latest information and updates:<br> <a href="http://nsis.sourceforge.net/StdUtils_plug-in">http://nsis.sourceforge.net/StdUtils_plug-in</a></p> <br> <a name="53c38996"></a><h1>Version History</h1> <ul> <li><b>Version 1.13, 2018-03-29</b> <ul> <li>Added new function <tt>${StdUtils.RandBytes}</tt> to generate a sequence of pseudo-random bytes. <li>Added new functions <tt>${StdUtils.ProtectStr}</tt> and <tt>${StdUtils.UnprotectStr}</tt> to encrypt/decrypt strings using the <a href="https://msdn.microsoft.com/en-us/library/ms995355.aspx">DPAPI</a>. <li>Added new function <tt>${StdUtils.StrToUtf8}</tt> and <tt>${StdUtils.StrFromUtf8}</tt> to convert a string to/from an UTF-8 byte sequence. <li>Added new function <tt>${StdUtils.ValidDomainName}</tt> to validate a given domain name string. <li>Various "internal" improvements to the pseudorandom number generator (<tt>${StdUtils.Rand*}</tt>) functions. </ul> <li><b>Version 1.12, 2017-12-12</b> <ul> <li>Added new function <tt>${StdUtils.SplitPath}</tt> to split a given path into separate components. <li>Added new function <tt>${StdUtils.GetDrivePart}</tt> to get the <i>drive letter</i> component of a given path. <li>Added new function <tt>${StdUtils.GetDirectoryPart}</tt> to get the <i>directory path</i> component of a given path. <li>Added new function <tt>${StdUtils.GetFileNamePart}</tt> to get the <i>file name</i> component of a given path. <li>Added new function <tt>${StdUtils.GetExtensionPart}</tt> to get the <i>file extension</i> component of a given path. <li>Added new function <tt>${StdUtils.GetOSReleaseId}</tt> to get the "Release Id" of Windows 10 (supersedes the "Service Pack" number) </ul> <li><b>Version 1.11, 2017-04-17</b> <ul> <li>Added new functions <tt>${StdUtils.NormalizePath}</tt> and <tt>${StdUtils.GetParentPath}</tt> for processing path strings <li>The <tt>GetParameter</tt> and <tt>TestParameter</tt> functions now recognizes the <tt>--name=value</tt> format <i>in addition</i> to the <tt>/name=value</tt> format. <li>The <tt>GetParameter</tt> and <tt>TestParameter</tt> functions now support <i>names</i> containing any graphical characters, except for the equality sign (<tt>=</tt>). <li>The <tt>GetRealOSName</tt> function now returns the name of the corresponding Windows Server edition, if we are running on a Server edition. <li>Minor fixes and improvements. </ul> <li><b>Version 1.10, 2016-05-14</b> <ul> <li>Using a simpler and (hopefully) more reliable approach in <tt>GetRealOSVersion</tt> function. <li>Minor fixes and improvements. </ul> <li><b>Version 1.09, 2015-11-16</b> <ul> <li>Modified the <tt>InvokeShellVerb</tt> function in order to make Startmenu pinning work on Windows 10. <li>Silently ignore unknown NSIS callback message values. </ul> <br> <li><b>Version 1.08, released 2015-10-10</b> <ul> <li>Modified the <tt>InvokeShellVerb</tt> function in order to make Taskbar pinning work on Windows 10. <li>Some code refactoring and clean-up has been applied. </ul> <br> <li><b>Version 1.07, released 2015-08-16</b> <ul> <li>Added new functions <tt>HashText</tt> and <tt>HashFile</tt>, which can be used to compute the cryptographic hash of the given file or string <li>Added new functions <tt>ValidFileName</tt> and <tt>ValidPathSpec</tt>, which can be used to test if a string is a valid file name or a valid full path <li>Added new function <tt>AppendToFile</tt>, which can be used to <i>append</i> the contents of one file to another (existing) file <li>Added new function <tt>TestParameter</tt>, which can be used to test whether a specific parameter is present on the command-line <li>Added new functions <tt>ParameterCnt</tt> and <tt>ParameterStr</tt>, which can be used to access the "raw" command-line tokens (like <tt>argv[i]</tt>) <li>Added new functions <tt>TimerCreate</tt> and <tt>TimerDestroy</tt>, which can be used to create a new window timer or stop an existing one. </ul> <br> <li><b>Version 1.06, released 2015-06-14</b> <ul> <li>Added new workaround to make the <tt>GetRealOSVersion</tt>, <tt>GetRealOSName</tt> and <tt>VerifyOSVersion</tt> functions work correctly on Windows 10<br> Microsoft has <u>broken</u> the <tt>VerifyVersionInfo()</tt> API in Windows 10, so we need to read the version of <tt>kernel32.dll</tt> directly now <li>Various fixes and improvements </ul> </ul> <br> <hr> <table width="100%"> <tr> <td align="left"><a href="http://muldersoft.com/">http://muldersoft.com/</a> | <a href="http://sourceforge.net/projects/muldersoft/">http://sourceforge.net/projects/muldersoft/</a> | <a href="http://nsis.sourceforge.net/Category:Plugins">http://nsis.sourceforge.net/Category:Plugins</a></td> <td align="right"><a href="https://www.youtube.com/v/uKUYSl8c-90?autoplay=1">Earth Heals Herself</a></td> </tr> </table> </body> </html>